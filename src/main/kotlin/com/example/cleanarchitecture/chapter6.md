# Chapter5. 아키텍처

- 시스템을 쉽게 개발, 배포, 운영, 유지보수하기 위해서는 가능한 많은 선택지를, 가능한 오래 남겨두는 전략을 따라야 한다
- 아키텍처의 목적은 시스템 생명주기를 지원하는 것
    - 좋은 아키텍처는 시스템을 쉽게 이해하고, 쉽게 개발하며, 쉽게 유지보수하고, 쉽게 배포하게 해준다
- 궁극적인 목표는 시스템의 수명과 관련된 비용은 최소화, 프로그래머의 생산성을 최대화
- 아키텍처랑 시스템의 동작 여부는 사실 관계 없음

### 개발

### 배포

### 운영

- 운영은 개발과 배포, 유지보수보다 비용 관점에서 덜 중요?
- 하드웨어를 늘리는 쪽으로 해결 가능하고, 개발 비용보단 하드웨어 비용이 싸다

### 유지보수

유지보수는 모든 측면에서 가장 비용이 드는 행위

유지보수의 가장 큰 비용은 탐사이다, 기능 추가를 위해 소프트웨어 어디를 고쳐야 할지, 어떤 전략을 쓰는 것이 최적일지 드는 비용

아키텍처에 주의를 기울이면 이런 비용을 최소화할 수 있음

### 선택 사항 열어두기

구체적인 내용의 결정은 최대한 미룰 것

모든 소프트웨어는 정책과 세부사항으로 분해할 수 있다

- 정책
    - 모든 업무 규칙과 업무 절차
- 세부사항
    - DB, 웹 시스템, 프레임워크, 통신 프로토콜
    

세부사항에 대한 결정을 최대한 미루고 세부사항에 관계 없는 고수준의 정책을 만들어라,

결정을 최대한 미룰 수록 더 많은 정보를 가지고 세부사항 결정 가능

### 정리

좋은 아키텍트는 세부사항을 정책으로부터 신중히 가려내고, 정책이 세부사항과 결합되지 않도록 엄격하게 분리

정책은 세부사항에 대해 알 필요 없고, 어떤 경우에도 의존하지 않도록 할 것

## 좋은 아키텍처

좋은 아키텍처는 다음을 지원해야 함

- 시스템의 유스케이스
- 시스템의 운영
- 시스템의 개발
- 시스템의 배포

### 유스케이스

시스템 아키텍처는 시스템의 의도를 지원해야 함

아키텍처의 최우선 관심사는 유스케이스여야 함

아키텍처에서 유스케이스를 일급 요소로 생각하고 알아보기 쉬운 곳에 배치하고 적절한 이름을 지을 것

### 운영

아키텍처는 요구 조건에 맞는 작업을 지원할 수 있는 형태로 만들어져야 한다

아키텍처간 컴포넌트를 적절히 격리하고, 컴포넌트간 통신 형태를 특정 형태로 제한하지 않을 것

이를 통해 병렬 스레드 사용, 단일 프로세서 사용 등 기술 스펙트럼에 구애되지 않고 상황에 맞게 전환 가능

### 배포

컴포넌트를 적절히 분할 격리하여 배포를 용이하게 할 것

### 선택사항 열어놓기

아키텍처 원칙을 정해 놓고

외에는 선택 사항을 열어 둠으로써 향후 시스템 변경이 필요할 때 쉽게 변경 가능하도록 할 것

## 유스케이스 결합 분리

시스템을 서로 결합되지 않은 수평적인 계층으로 분리할 것

계층으로는 UI, 비즈니스 로직, 데이터베이스 등이 있음

유스케이스별로 UI, 비즈니그 로직, 데이터베이스를 묶어서 분리

예를 들어 주문 추가와 삭제에 필요한 각각의 UI, 로직, DB를 묶는다

### 중복

진짜 중복과 가짜 중복을 구분하라

각자의 경로로 발전하여 달라질 수 있다면 가짜 중복

### 번외

도메인과 유스케이스

도메인은 각자의 정책을 갖는다, 값의 유효성 검사 등등

예를 들어 한 적금의 이율과 가입 기간 등등

유스케이스는 비즈니스적인 정책을 갖는다

예를 들어 적금 가입을 위해서는 신용점수가 300점 이상이어야 한다 등등

## 17장

### 플러그인 아키텍처

비즈니스 로직과 인터페이스가 있고, GUI나 DB 같은 세부 사항을 플러그인 형태로 사용할 수 있는 아키텍처

사용자 인터페이스를 플러그인 형태로 고려하였기 때문에, 수많은 종류의 사용자 인터페이스를 플러그인 형태로 연결 가능

이를 통해 확장 가능하며 유지보수가 쉬운 시스템 아키텍처 확립 가능 

젯 브레인은 러시아 회사다..?!?!?

### 플러그인에 대한 논의

시스템을 플러그인 아키텍처로 배치함으로써 중요한 비즈니스 로직을 외부 변경으로부터 보호 가능,

경계를 긋는 기준은 변경의 이유, 속도가 다른 컴포넌트들 사이를 경계로 분리

(단일 책임 원칙)

### 결론

시스템을 컴포넌트 단위로 분할한다

핵심 업무 규칙에 관한 컴포넌트를 배치하고 나머지 컴포넌트들이 플러그인처럼 해당 핵심 업무를 향하도록 배치

## 18장 경계 해부학

### 경계 횡단하기

런타임에 경계를 횡단한다는 것은 경계 한쪽에서 다른 쪽의 함수를 호출하여 데이터를 전달받는 일

### 두려운 단일체

같은 물리공간에 있다고 경계가 의미 없는 것은 아님

??????

### 19장 정책과 수준

컴퓨터 프로그램은 각 입력을 출력으로 변환하는 정책을 상세히 기술한 것

소프트웨어 아키텍처를 개발하는 기술에는 이러한 정책을 신중하게 분리하고, 정책이 변경되는 양상에 따라 정책을 재편성하는 일도 포함되야 함

동일한 이유로 동일한 시점에 변경되는 정책은 동일한 수준에 위치하며, 동일한 컴포넌트에 속해야 한다.

서로 다른 이유로 다른 시점에 분리되는 정책은 다른 수준의 다른 컴포넌트로 분리해야 한다

그리고 컴포넌트의 의존 방향은 저수준에서 고수준으로 향해야 한다

### 수준

수준이란 엄밀히 정의하면 **입력과 출력까지의 거리**

시스템의 입력과 출력 모두로부터 멀리 위치할수록 정책의 수준은 높아진다.

입력과 출력을 다루는 정책이라면 시스템에서 최하위 수준에 위치

입력과 출력에서 떨어진 고수준 정책은 저수준 정책에 비해 덜 빈번하게 변경되고 보다 중요한 이유로 변경되는 경향이 있다.

반대로 저수준 정책은 더 빈번하고, 덜 중요한 이유로 변경될 수 있음

이것을 저수준 컴포넌트가 고수준 컴포넌트에 플러그인되어야 한다는 관점으로 바라볼 수도 있다나 뭐라나

### 결론

이 장에서 설명한 정책이라는 것은

단일 책임 원칙, 개방 폐쇄 원칙, 공통 폐쇄 원칙, 의존성 역전 원칙, 안정된 의존성 원칙, 안정된 추상화 원칙을 모두 포함한다.

다시 읽어보며 각 원칙이 어디에서 무슨 이유로 사용되었는지 복습해라 좀

## 20장 업무 규칙

애플리케이션을 업무 규칙과 플러그인으로 구분하기 위해서는 업무 규칙이 실제로 무엇인지 이해해야 한다.

업무 규칙이란 사업적으로 수익을 얻거나 비용을 줄일 수 있는 절차, 컴퓨터상으로 구현했는지와 별개로 업무 규칙은 사업적으로 수익을 내거나 비용을 줄일 수 있어야 한다

예를 들어 `대출에는 N% 이자를 부여한다`는 사실은 은행이 돈을 버는 업무 규칙, 

컴퓨터 프로그램으로 계산하든, 계산기로 직원이 계산하든 관계 없다.

이러한 규칙을 **핵심 업무 규칙**이라고 부를 것이다. 이러한 규칙은 사업 자체에 핵심적이며, 규칙을 자동화하는 시스템이 없더라도 업무 규칙은 그대로 존재하기 때문

핵심 업무 규칙은 보통 데이터를 요구한다. 대출 잔액, 이자율, 지급 일정 등등

이러한 데이터를 **핵심 업무 데이터** 라고 부르겠다. 

이러한 데이터는 시스템적으로 자동화되지 않은 경우에도 존재하는 그런 데이터.

**핵심 규칙**과 **핵심 데이터**는 본질적으로 결합되어 있기 때문에 객체로 만들 좋은 후보가 되고, **이러한 유형의 객체를 엔티티**라고 한다.

### 엔티티

컴퓨터 시스템 내부의 객체

핵심 업무 데이터 기반의 핵심 업무 규칙을 구체화

이 클래스는 업무의 대표자로써 독립적으로 존재

어떤 시스템에서도 업무를 수행할 수 있으며, 시스템의 표현 방식이나 데이터 저장 방식, 해당 시스템에서 컴퓨터가 배치되는 방식과도 무관하다.

엔티티는 순전히 업무를 위한 것이며, 이외의 것은 없다

### 유스케이스

자동화된 시스템이 동작하는 방법을 정의하고 제약하는 업무 규칙을 정의

예를 들어, 신규 대출 생성에서 

- 신상 정보 수집 및 검증
- 신용도가 500 보다 낮다면 대출 견적 제공하지 않음

이러한 시스템적인 애플리케이션에 특화된 업무 요건을 정의한 것이 유스케이스

유스케이스는 엔티티 내부의 핵심 업무 규칙을 어떻게, 언제 호출할지 명시하는 규칙을 담는다.

엔티티를 유스케이스가 제어

엔티티는 유스케이스에 대해 알아서는 안된다

유스케이스는 사용자에게 어떻게 보이는지에 관한 내용을 담아서는 안된다.

유스케이스는 객체로 애플리케이션에 특화된 하나 이상의 함수를 제공한다.

또한 입력 데이터, 출력 데이터, 유스케이스가 상호작용하는 엔티티에 대한 참조 데이터 등의 데이터 요소를 포함한다.

## 21장 소리치는 아키텍처

아키텍처만 보고서라도 어떤 소프트웨어인지 어떤 유스케이스를 담당하는지 알 수 있어야 한다

### 아키텍처의 목적

웹이든 클라이언트 앱이든 잘 설계된 아키텍처라면 이런 세부사항을 분리하여 영향이 가지 않도록 한다

또한 프레임워크가 없더라도 유스케이스 전부에 대해 단위 테스트를 할 수 있어야 한다

## 22장 클린 아키텍처

헥사고날, DCI, BCE 등 다양한 시스템 아키텍처와 관련된 아이디어들이 있었음

이 아키텍처들의 공통점은 관심사의 분리

소프트웨어를 계층으로 분리함으로써 관심사를 분리하는 아키텍처 들이다

각 아키텍처는 최소한 업무 규칙을 위한 계층 하나와, 사용자와 시스템 인터페이스를 위한 계층 하나를 반드시 포함한다

위 아키텍처들의 특징

- 프레임워크 독립성
- 테스트 용이성
    - 세부사항 없이도 테스트 가능
- UI 독립성
- 데이터베이스 독립성
- 외부 에이전시에 대한 독립성

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/33fbbdf6-7615-4ed4-9f65-64614855c063/d0b50c17-8c2c-47a7-bf5e-f2fc84815346/Untitled.png)

- 엔티티
    - 전사적인 핵심 업무 규칙을 캡슐화
    - 기업의 다양한 애플리케이션에서 엔티티를 재사용 가능해야 한다
- 유스케이스
    - 애플리케이션에 특화된 업무 규칙
    - 유스케이스 계층의 소프트웨어는 모든 유스케이스를 캡슐화하고 구현
    - 엔티티로 들어오가 나가는 데이터 흐름을 조정하며, 엔티티가 유스케이스의 목적을 달성하도록 돕는다
    - UI나 DB의 변경에 영향을 받지는 않지만, 애플리케이션이 변하면 영향을 받는다
- 인터페이스 어뎁터
    - 어댑터는 데이터를 유스케이스와 엔티티에게 가장 편리한 형식에서 웹, DB 등 외부 에이전시에게 편리한 방식으로 변환한다
    - 프레임워크에 영향을 받으며 프레임워크가 사용하기 편리한 형식으로 변환한다
    - 원 안에 있는 어떤 코드도 외부에 대해 알아서는 안됨
- 프레임워크와 드라이버
    - DB, 웹 프레임워크 등등

항상 안쪽 원이 바깥쪽에 의존해서는 안됨

### 경계를 횡단할 때의 데이터 구조

경계를 가로지르는 데이터는 대체로 간단한 구조

구조체나 dto 혹은 간단한 인자를 사용하여 데이터 전달

이러한 데이터 구조 역시 어떠한 의존성을 가져서는 안된다

Plain Old (Java) Object 일 것

## 23장 프레젠터와 험블 객체

### 험블 객체 패턴

테스트하기 어려운 행위와 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법

- 행위를 두 개의 모듈로 나눈다, 두 모듈 중 하나가 험블 객체
- 테스트하기 어려운 행위를 모두 험블 객체로 옮긴다, 테스트 하기 쉬운 행위는 햄블 객체가 아닌 객체에 옮긴다

### 프레젠터와 뷰

뷰는 험블 객체이고 테스트하기 어렵다(네트워크가 들어가야 해서 그런 듯?)

뷰는 데이터를 GUI로 이동시키지만, 데이터를 직접 처리하지는 않는다

프레젠터는 테스트하기 쉬운 객체다. 애플리케이션으로부터 데이터를 받아 화면에 표현할 수 있는 포맷으로 만든다.

프레젠터는 애플리케이션의 Data 객체를 받아 뷰 모델이라 불리는 간단한 데이터 구조에 담는다,

뷰는 뷰 모델에서 필요한 데이터를 사용?

### 테스트와 아키텍처

**테스트 용이성은 좋은 아키텍처가 지녀야 할 속성**

테스트하기 쉬운 부분과 어려운 부분을 분리하면 아키텍처의 경계가 정의 됨

관련된 디자인 패턴이 험블 객체

### 데이터베이스 게이트웨이

유스케이스 인터랙터와 데이터베이스 사이에는 게이트웨이가 위치

DB에서 수행되어야 할 모든 메서드를 가지고 있다

유스케이스는 게이트웨이 인터페이스를 호출한다.

그리고 인터페이스의 구현체는 데이터베이스 계층에 위치한다

구현체는 험블 객체

구현체에서 직접 SQL을 사용하거나 데이터베이스에 대한 임의의 인터페이스를 통해 게이트웨이의 메서드에서 필요한 데이터에 접근한다.

게이트웨이는 테스트하기 쉽다, 적당한 스텁으로 교체할 수 있기 때문

### 데이터 매퍼

ORM은 데이터베이스 계층

객체는 데이터 구조가 아니라 사용자 입장에서 사실 행위의 집합

그래서 ORM보다는 데이터 매퍼가 더 맞는 표현이라고 주장함

### 서비스 리스너

애플리케이션이 다른 서비스와 통신할 경우, 여기에서 서비스 경계를 생성하는 험블 객체 패턴을 발견 가능

애플리케이션은 데이터를 간단한 데이터 구조 형태로 로드한 후, 이 데이터 구조 경계를 가로질러 특정 모듈로 전달,

해당 모듈이 데이터 전송

다른 서비스로부터 데이터를 수신하는 서비스의 경우, 서비스 리스너가 서비스 인터페이스로부터 데이터 수신하고, 데이터를 애플리케이션에서 사용할 수 있게 간단한 데이터 구조로 포맷을 변경

### 결론

각 아키텍처 경계마다 경계 가까이 숨어 있는 험블 객체 패턴을 발견할 수 있을 것이다.

험블 객체 패턴을 통해 테스트하기 어려운 부분과 쉬운 부분을 분리하여 시스템의 테스트 용이성을 높여 보자

## 24장 부분적 경계

클린 아키텍처를 위해서는 많은 비용을 필요로 한다.

하지만 YAGIN 원칙을 위배하기 때문에 탐탁지 않으면서도 해야 하지 않을까 싶기도 할 것이다.

이럴 때 사용하는 것이 부분적 경계

### 마지막 단계를 건너뛰기

컴포넌트를 분리할 수 있는 환경을 구성한 후 단일 컴포넌트에 모아만 두는 것

???????

### 일차원 경계

### 퍼사드

## 25장 계층과 경계
